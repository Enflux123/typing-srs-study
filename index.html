<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Queue Study App — Custom SRS</title>
<style>
#answerInput {
  margin-top: 16px; /* adjust value as needed */
}

  :root{
    --bg:#f3f4f6; --card:#fff; --text:#111;
    --new:#777; --learning:#2196f3; --applying:#7c4dff; --mastered:#2e7d32;
    --accent:#3b82f6;
  }
  [data-theme="dark"]{
    --bg:#0b1020; --card:#0f1724; --text:#eef2ff;
  }
  body{ margin:0; font-family:Inter,system-ui,Segoe UI,Arial; background:var(--bg); color:var(--text); }
  .app{ display:flex; gap:14px; min-height:100vh; padding:20px; box-sizing:border-box; }
  .main{ flex:1; max-width:900px; margin:auto; }
  .controls{ display:flex; gap:12px; align-items:center; margin-bottom:12px; flex-wrap:wrap; }
  .card{ background:var(--card); border-radius:12px; box-shadow:0 6px 24px rgba(13,20,40,0.06); padding:16px; }
  textarea, input[type="text"], input[type="number"]{ width:100%; padding:10px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); box-sizing:border-box; background:transparent; color:var(--text) }
  button{ padding:8px 12px; border-radius:8px; border:0; cursor:pointer; background:var(--accent); color:white }
  button.ghost{ background:transparent; color:var(--text); border:1px solid rgba(0,0,0,0.06) }
  .layout{ display:flex; gap:14px; align-items:flex-start; }
  .left{ flex:1; min-width:420px; }
  .side{ width:280px; }
  .studyArea{ margin-top:12px; display:flex; flex-direction:column; gap:10px }
  .termRow{ display:flex; align-items:center; gap:10px; justify-content:space-between }
  .termTitle{ font-size:20px; font-weight:700 }
  .statusTag{ padding:6px 8px; border-radius:10px; color:white; font-weight:600; font-size:12px; }
  .status-new{ background:var(--new) }
  .status-learning{ background:var(--learning) }
  .status-applying{ background:var(--applying) }
  .status-mastered{ background:var(--mastered); color:#000 }
  .definition{ font-size:16px; padding:10px; background:rgba(0,0,0,0.03); border-radius:8px; display:none }
  .controlsRow{ display:flex; gap:8px; align-items:center; }
  .small{ font-size:13px; color:gray }
  .queuePanel{ width:280px; display:flex; flex-direction:column; gap:8px; position:sticky; top:20px; height:calc(100vh - 40px); overflow:auto; }
  .queueHeader{ display:flex; justify-content:space-between; align-items:center; gap:8px }
  .queueList{ margin-top:8px; display:flex; flex-direction:column; gap:6px }
  .queueItem{ display:flex; align-items:center; gap:8px; padding:8px; border-radius:8px; background:linear-gradient(180deg, rgba(0,0,0,0.02), transparent); }
  .colorBox{ width:12px; height:12px; border-radius:3px; flex:0 0 12px }
  .offsetBadge{ margin-left:auto; font-size:13px; color:#444; font-weight:700 }
  .counters{ display:flex; gap:12px; margin-top:8px; }
  .counter{ padding:8px 10px; border-radius:8px; background:linear-gradient(180deg, rgba(0,0,0,0.03), transparent); font-weight:700 }
  .toggle{ display:inline-flex; gap:8px; align-items:center; padding:6px 8px; border-radius:999px; background:rgba(0,0,0,0.03) }
  .hidden{ display:none }
  .btn-correct{ background:#16a34a }
  .btn-wrong{ background:#ef4444 }
  /* responsive */
  @media (max-width:980px){
    .app{ padding:12px }
    .layout{ flex-direction:column; }
    .side{ width:100% }
  }
</style>
<style>
  /* ... existing styles ... */

  /* ===== Term row layout updates ===== */
  .termRow {
    display: flex;
    align-items: center;
    justify-content: space-between; /* left & right elements stick to edges */
    position: relative; /* allows termTitle to be centered absolutely */
  }

  .termTitle {
    font-size: 20px;
    font-weight: 700;
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
  }

  #triesLabel {
    flex-shrink: 0; /* ensures it doesn’t shrink */
  }

  .statusTag {
    flex-shrink: 0; /* ensures it doesn’t shrink */
  }
</style>

</head>
<body>
<div class="app" id="root">
  <div class="main">
    <div class="card controls">
      <div style="flex:1; min-width:260px">
        <label class="small">Import (Term | Definition, one per line)</label>
        <textarea id="importBox" rows="4" placeholder="e.g. Photosynthesis | Process plants use to convert sunlight"></textarea>
        <div style="display:flex; gap:8px; margin-top:8px">
          <button id="importBtn">Import</button>
          <button id="clearBtn" class="ghost">Clear All Cards</button>
<label class="toggle" title="Dark mode">
  <input type="checkbox" id="darkToggle"> Dark
</label>

<div style="display:flex; gap:6px; align-items:center">
  <span class="small">Keybinds:</span>
  <input type="text" id="keyCorrect" maxlength="1" title="Key for Correct" style="width:24px" value="[">
  <input type="text" id="keyWrong" maxlength="1" title="Key for Wrong" style="width:24px" value="]">
</div>

        </div>
      </div>

      <div style="width:220px">
        <div style="display:flex; gap:8px; align-items:center">
          <label class="small">Wrong delay (sec)</label>
          <input id="delayInput" type="number" value="2" min="0" style="width:70px">
        </div>
        <div style="margin-top:8px" class="small">Note: Change delay before starting session.</div>
      </div>
    </div>

    <div class="layout">
      <div class="left">
        <div class="card">
          <div style="display:flex; justify-content:space-between; align-items:center">
            <div>
              <strong>Study</strong>
              <div class="small">Type answer → Enter (reveal) → Correct / Wrong</div>
            </div>
            <div style="display:flex; gap:8px; align-items:center">
              <div class="small"> <label>Show queue</label></div>
              <button id="startBtn">Start Session</button>
              <button id="pauseBtn" class="ghost hidden">Pause</button>
            </div>
          </div>

          <div class="studyArea" id="studyArea" style="display:none">
<div class="termRow">
  <div id="triesLabel" class="small">Tries: 0</div>
  <div class="termTitle" id="termTitle">—</div>
  <div>
    <span id="statusTag" class="statusTag status-new">New</span>
  </div>
</div>


            <div>
              <input id="answerInput" type="text" placeholder="Type your answer and press Enter" autocomplete="off" />
            </div>

            <div class="definition" id="definitionBox"></div>

            <div id="judgeRow" style="display:none; margin-top:6px; display:flex; gap:8px">
              <button id="correctBtn" class="btn-correct" style="padding:8px 12px; border-radius:8px; color:white">Correct</button>
              <button id="wrongBtn" class="btn-wrong" style="padding:8px 12px; border-radius:8px; color:white">Wrong</button>
              <div id="nextInfo" class="small" style="margin-left:auto"></div>
            </div>
          </div>
        </div>

        <div id="sessionComplete" class="card hidden" style="margin-top:12px">
          <h3>Session complete</h3>
          <div class="small">You studied all queued cards.</div>
          <div style="margin-top:8px">
            <button id="restartBtn">Restart Session</button>
          </div>
        </div>
      </div>

      <div class="side">
        <div class="card queuePanel">
          <div class="queueHeader">
            <div><strong>Queue</strong></div>
            <div><button id="toggleQueueBtn" class="ghost">Hide</button></div>
          </div>

          <div class="counters" style="margin-top:6px">
            <div class="counter">New: <span id="countNew">0</span></div>
            <div class="counter">In Queue: <span id="countInQueue">0</span></div>
            <div class="counter">Mastered: <span id="countMastered">0</span></div>
          </div>

          <div id="queueList" class="queueList" style="margin-top:8px"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>

/* ========= Data model & persistence ========= */
const STORAGE_KEY = 'queueStudyApp.v1';

let store = {
  cards: [],   // { id, term, def, status:'new'|'learning'|'applying'|'mastered', streak:0 }
  settings: { wrongDelay: 2, darkMode: false }
};
let queue = []; // array of items: { cardId, offset? }  offset present only when reinserted (+5/+10)
let current = null; // { cardId, offset? }
let tries = 0;
let inputLocked = false;
let sessionActive = false;

// Helper IDs
const el = id => document.getElementById(id);

/* ---------- persistence ---------- */
function saveStore() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify({ store, queue }));
}
function loadStore() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (raw) {
      const parsed = JSON.parse(raw);
      if (parsed.store) store = parsed.store;
      if (Array.isArray(parsed.queue)) queue = parsed.queue;
    }
  } catch(e){ console.warn('load error', e); }
}
loadStore();

/* ========= Utilities ========= */
function uid(){ return Math.random().toString(36).slice(2,9); }
function getCard(id){ return store.cards.find(c=>c.id===id) || null; }
function mapStatusToClass(s){
  if(s==='new') return ['New','status-new','--'];
  if(s==='learning') return ['Learning','status-learning','--'];
  if(s==='applying') return ['Applying','status-applying','--'];
  if(s==='mastered') return ['Mastered','status-mastered','--'];
  return ['New','status-new','--'];
}
function updateCountersUI(){
  const newCount = store.cards.filter(c=>c.status==='new').length;
  const masteredCount = store.cards.filter(c=>c.status==='mastered').length;
  // In Queue = queued cards that are not new
  const inQueueCount = queue.filter(item=>{
    const c = getCard(item.cardId);
    return c && c.status !== 'new';
  }).length;
  el('countNew').textContent = newCount;
  el('countInQueue').textContent = inQueueCount;
  el('countMastered').textContent = masteredCount;
}
/* ========= Import / Clear ========= */
el('importBtn').addEventListener('click', ()=>{
  const raw = el('importBox').value.trim();
  if(!raw) return;
  const lines = raw.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  for(const line of lines){
    const parts = line.split('|');
    if(parts.length < 2) continue;
    const term = parts[0].trim(), def = parts.slice(1).join('|').trim();
    store.cards.push({ id: uid(), term, def, status: 'new', streak: 0 });
  }
  el('importBox').value = '';
  // If session not active, add to queue so they will be studied in next session
  saveStore();
  renderQueueUI();
  updateCountersUI();
});
el('clearBtn').addEventListener('click', ()=>{
  if(!confirm('Clear ALL cards and progress?')) return;
  store.cards = [];
  queue = [];
  saveStore();
  renderQueueUI();
  updateCountersUI();
  endSession();
});

/* ========= Dark mode ========= */
const darkToggle = el('darkToggle');
darkToggle.addEventListener('change', ()=>{
  store.settings.darkMode = darkToggle.checked;
  applyTheme();
  saveStore();
});
function applyTheme(){
  if(store.settings.darkMode){
    document.documentElement.setAttribute('data-theme','dark');
    darkToggle.checked = true;
  } else {
    document.documentElement.removeAttribute('data-theme');
    darkToggle.checked = false;
  }
}
applyTheme();

/* ========= Queue & Session logic ========= */

function buildQueueFromCards(){
  // Build queue from all cards in stored order (clone)
  queue = store.cards.map(c=>({ cardId: c.id })); // initially no offsets
  saveStore();
  renderQueueUI();
  updateCountersUI();
}

// Start session
el('startBtn').addEventListener('click', ()=>{
  if(store.cards.length === 0){ alert('No cards imported. Paste Term | Definition and Import.'); return; }
  // ensure queue exists
  if(queue.length === 0) buildQueueFromCards();

  // load wrong delay
  const d = parseInt(el('delayInput').value);
  store.settings.wrongDelay = isNaN(d) ? 0 : Math.max(0, d);
  saveStore();
  sessionActive = true;
  el('studyArea').style.display = 'block';
  el('sessionComplete').classList.add('hidden');
  nextCard();
  renderQueueUI();
  updateCountersUI();
});

el('restartBtn').addEventListener('click', ()=>{
  // restart fresh session with queue from store
  buildQueueFromCards();
  sessionActive = true;
  el('studyArea').style.display = 'block';
  el('sessionComplete').classList.add('hidden');
  nextCard();
});

/* End session */
function endSession(){
  sessionActive = false;
  el('studyArea').style.display = 'none';
  el('sessionComplete').classList.add('hidden');
  current = null;
  tries = 0;
  saveStore();
}

/* Pop next card */
function nextCard(){
  if(!sessionActive) return;
  if(queue.length === 0){
    // done
    el('studyArea').style.display = 'none';
    el('sessionComplete').classList.remove('hidden');
    current = null;
    tries = 0;
    renderQueueUI();
    updateCountersUI();
    saveStore();
    return;
  }
  // get the next queued item
  const item = queue.shift();
  current = item;
  tries = 0;
  inputLocked = false;
  renderCurrentCard();
  renderQueueUI();
  updateCountersUI();
  saveStore();
}

/* Render the current shown card */
function renderCurrentCard(){
  if(!current){ el('termTitle').textContent = '—'; return; }
  const card = getCard(current.cardId);
  if(!card){ nextCard(); return; }
  el('termTitle').textContent = card.term;
  el('triesLabel').textContent = `Tries: ${tries}`;
  // status tag
  const [label, cls] = mapStatusToClass(card.status);
  el('statusTag').textContent = label;
  el('statusTag').className = `statusTag ${cls}`;
  // hide definition + judge row until user submits
  el('definitionBox').style.display = 'none';
  el('definitionBox').textContent = '';
  el('judgeRow').style.display = 'none';
  el('answerInput').value = '';
  el('answerInput').disabled = false;
  el('answerInput').focus();
}

/* When user presses Enter to reveal definition */
el('answerInput').addEventListener('keydown', (e)=>{
  if(e.key === 'Enter' && !inputLocked && sessionActive && current){
    e.preventDefault();
    showDefinition();
  }
});

function showDefinition(){
  if(!current) return;
  const card = getCard(current.cardId);
  if(!card) return;
  el('definitionBox').textContent = card.def;
  el('definitionBox').style.display = 'block';
  el('judgeRow').style.display = 'flex';
}

/* Wrong button logic:
   - increment tries
   - demote status one level
   - hide definition and lock input for wrongDelay seconds, then allow retry
   - note: card remains at front (we do not reinsert yet). Only when user eventually presses Correct will insertion happen
*/
el('wrongBtn').addEventListener('click', ()=> {
  if(!current) return;
  tries++;
  const card = getCard(current.cardId);
  if(!card) return;
  demoteCard(card);

  // adjust offset: reduce 5 but not below 0
  const newOffset = Math.max((current.offset || 0) - 5, 0);
  current.offset = newOffset;

  el('definitionBox').style.display = 'none';
  el('judgeRow').style.display = 'none';
  inputLocked = true;
  el('answerInput').disabled = true;

  const delayMs = (store.settings.wrongDelay || 0) * 1000;
  setTimeout(()=>{
    inputLocked = false;
    el('answerInput').disabled = false;
    el('answerInput').focus();
    renderCurrentCard();
  }, delayMs);

  saveStore();
  renderQueueUI();
  updateCountersUI();
});

/* Correct button logic:
   - If tries === 0 or ===1? In our flow: user must press Enter to reveal, which does not increment tries.
     We increment tries when they press Wrong. So "first try" means tries === 0 (they typed and pressed Enter and then pressed Correct immediately.)
   - We'll follow: first correct without previous wrongs => first try
   - If there were any wrongs (tries >= 1) => considered multi-try
   - Based on that we insert back into queue with offset +10 (first try) or +5 (multi-try)
   - If first try, promote streak ++ else streak = 0
*/
el('correctBtn').addEventListener('click', ()=> {
  if(!current) return;
  const card = getCard(current.cardId);
  if(!card) return;

  const hadWrong = tries > 0;

  // promotion/demotion logic
  if(!hadWrong){
    card.streak = (card.streak || 0) + 1;
    if(card.streak === 1) card.status = 'learning';
    else if(card.streak === 2) card.status = 'applying';
    else if(card.streak >= 3) card.status = 'mastered';
  } else {
    card.streak = 0;
  }

  // determine insertion offset
  let insertAfter = (current.offset || 0) + 5; // +5 for correct
  insertAfter = Math.min(insertAfter, queue.length); // cap at queue length

  const queueItem = { cardId: card.id, offset: insertAfter };
  queue.splice(insertAfter, 0, queueItem);

  saveStore();
  renderQueueUI();
  updateCountersUI();
  nextCard();
});




/* Demotion (one level down) when Wrong is pressed */
function demoteCard(card){
  // levels: mastered -> applying -> learning -> new
  if(card.status === 'mastered') card.status = 'applying';
  else if(card.status === 'applying') card.status = 'learning';
  else if(card.status === 'learning') card.status = 'new';
  else card.status = 'new';
  // reset streak when demoted
  card.streak = Math.max(0, (card.streak || 0) - 1);
}

/* ========= Queue panel rendering ========= */
function renderQueueUI(){
  const qList = el('queueList');
  qList.innerHTML = '';
  for(let i=0;i<queue.length;i++){
    const item = queue[i];
    const card = getCard(item.cardId);
    if(!card) continue;
    const node = document.createElement('div');
    node.className = 'queueItem';
    // color box
    const box = document.createElement('div');
    box.className = 'colorBox';
    if(card.status === 'new') box.style.background = getComputedStyle(document.documentElement).getPropertyValue('--new').trim() || '#777';
    else if(card.status === 'learning') box.style.background = getComputedStyle(document.documentElement).getPropertyValue('--learning').trim() || '#2196f3';
    else if(card.status === 'applying') box.style.background = getComputedStyle(document.documentElement).getPropertyValue('--applying').trim() || '#7c4dff';
    else if(card.status === 'mastered') box.style.background = getComputedStyle(document.documentElement).getPropertyValue('--mastered').trim() || '#2e7d32';
    node.appendChild(box);
    // term
    const span = document.createElement('div');
    span.textContent = card.term;
    node.appendChild(span);
    // reinsert offset badge — show only if this queued item has offset
    if(item.offset){
      const off = document.createElement('div');
      off.className = 'offsetBadge';
      off.textContent = `+${item.offset}`;
      node.appendChild(off);
    }
    qList.appendChild(node);
  }
  updateCountersUI();
}

/* Toggle queue panel visibility */
const toggleQueueBtn = el('toggleQueueBtn');
toggleQueueBtn.addEventListener('click', ()=>{
  const q = el('queueList');
  if(q.style.display === 'none'){ q.style.display = 'flex'; toggleQueueBtn.textContent = 'Hide'; }
  else { q.style.display = 'none'; toggleQueueBtn.textContent = 'Show'; }
});

/* Load persisted state into UI */
function initializeUI(){
  // settings
  el('delayInput').value = store.settings.wrongDelay || 0;
  store.settings.darkMode = store.settings.darkMode || false;
  darkToggle.checked = !!store.settings.darkMode;
  applyTheme();
  // if queue was persisted, use it; otherwise build from cards
  if(!queue || queue.length === 0) {
    // create initial queue only if cards exist
    if(store.cards.length) buildQueueFromCards();
  }
  renderQueueUI();
  updateCountersUI();
}
initializeUI();

/* helper: build queue from store.cards preserving order */
function buildQueueFromCards(){
  queue = store.cards.map(c=>({ cardId: c.id })); // offsets empty
  saveStore();
}

/* Persist store + queue whenever user leaves or on interval */
window.addEventListener('beforeunload', ()=> saveStore());

/* expose small debug functions to console if needed */
window.QSApp = { store, queue, saveStore, loadStore, nextCard, getCard };

// Initialize keybinds
store.settings.keyCorrect = store.settings.keyCorrect || '[';
store.settings.keyWrong = store.settings.keyWrong || ']';

// Update inputs with stored keys
el('keyCorrect').value = store.settings.keyCorrect;
el('keyWrong').value = store.settings.keyWrong;

// Save keybinds when changed
el('keyCorrect').addEventListener('change', e=>{
  store.settings.keyCorrect = e.target.value.slice(0,1);
  saveStore();
});
el('keyWrong').addEventListener('change', e=>{
  store.settings.keyWrong = e.target.value.slice(0,1);
  saveStore();
});

// Listen for key presses
document.addEventListener('keydown', e=>{
  if(!sessionActive) return;
  if(current && !inputLocked){
    if(e.key === store.settings.keyCorrect){
      e.preventDefault();
      el('correctBtn').click();
    }
    if(e.key === store.settings.keyWrong){
      e.preventDefault();
      el('wrongBtn').click();
    }
  }
});

</script>
</body>
</html>


