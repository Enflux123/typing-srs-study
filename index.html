<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Queue Study App — Custom SRS</title>
<style>
/* Space between termRow and definition */
#definitionBox {
  margin-top: 16px; /* adjust as needed */
}
.termRow {
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: relative;
  margin-top: 20px; /* moves the entire row down */
  /* or use padding-top instead: padding-top: 12px; */
}
#pausePlayBtn {
    position: absolute;
  font-size: 24px;
  width: 48px;
  height: 48px;
  border-radius: 50%;
  border: none;
  cursor: pointer;
  background: transparent;
  color: var(--pausePlayColor);
  top: 70px;      
  left: 69.6%;
}

/* Light mode */
:root {
  --pausePlayColor: #000; /* black in light mode */
}

/* Dark mode */
[data-theme="dark"] {
  --pausePlayColor: #fff; /* white in dark mode */
}

#answerInput {
  margin-top: 16px; /* space below input */
}

#judgeRow {
  margin-top: 20px; /* extra spacing if needed */
}

#correctBtn {
  margin-top: 20px; /* adjust value as needed */
}
#wrongBtn {
  margin-top: 20px; /* adjust value as needed */
}
#keyCorrect, #keyWrong, #keybindContainer {
  display: none;
}
#sessionTimer {
  position: absolute;       /* takes it out of flow so it doesn’t push others */
  top: 70px;                /* adjust depending on where you want it */
  left: 66.5%;
  transform: translateX(-50%);
  font-size: 45px;          /* bigger font */
  font-weight: bold;
  text-align: center;
  pointer-events: none;     /* won’t block clicks */
}
#avgTime {
  position: absolute;
  top: 128px;                /* sits right under timer */
  left: 66.5%;
  transform: translateX(-50%);
  font-size: 13px;
  font-weight: normal;
  text-align: center;
  color: #444;
}
  :root{
    --bg:#f3f4f6; --card:#fff; --text:#111;
    --new:#777; --learning:#2196f3; --applying:#7c4dff; --mastered:#2e7d32;
    --accent:#3b82f6;
  }
  [data-theme="dark"]{
    --bg:#0b1020; --card:#0f1724; --text:#eef2ff;
  }
  body{ margin:0; font-family:Inter,system-ui,Segoe UI,Arial; background:var(--bg); color:var(--text); }
  .app{ display:flex; gap:14px; min-height:100vh; padding:20px; box-sizing:border-box; }
  .main{ flex:1; max-width:900px; margin:auto; }
  .controls{ display:flex; gap:12px; align-items:center; margin-bottom:12px; flex-wrap:wrap; }
  .card{ background:var(--card); border-radius:12px; box-shadow:0 6px 24px rgba(13,20,40,0.06); padding:16px; }
  textarea, input[type="text"], input[type="number"]{ width:100%; padding:10px 12px; border-radius:8px; border:1px solid rgba(0,0,0,0.08); box-sizing:border-box; background:transparent; color:var(--text) }
  button{ padding:8px 12px; border-radius:8px; border:0; cursor:pointer; background:var(--accent); color:white }
  button.ghost{ background:transparent; color:var(--text); border:1px solid rgba(0,0,0,0.06) }
  .layout{ display:flex; gap:14px; align-items:flex-start; }
  .left{ flex:1; min-width:420px; }
  .side{ width:280px; }
  .studyArea{ margin-top:12px; display:flex; flex-direction:column; gap:10px }
  .termRow{ display:flex; align-items:center; gap:10px; justify-content:space-between }
  .termTitle{ font-size:20px; font-weight:700 }
  .statusTag{ padding:6px 8px; border-radius:10px; color:white; font-weight:600; font-size:12px; }
  .status-new{ background:var(--new) }
  .status-learning{ background:var(--learning) }
  .status-applying{ background:var(--applying) }
  .status-mastered{ background:var(--mastered); color:#000 }
  .definition{ font-size:16px; padding:10px; background:rgba(0,0,0,0.03); border-radius:8px; display:none }
  .controlsRow{ display:flex; gap:8px; align-items:center; }
  .small{ font-size:13px; color:gray }
  .queuePanel{ width:280px; display:flex; flex-direction:column; gap:8px; position:sticky; top:20px; height:calc(100vh - 40px); overflow:auto; }
  .queueHeader{ display:flex; justify-content:space-between; align-items:center; gap:8px }
  .queueList{ margin-top:8px; display:flex; flex-direction:column; gap:6px }
  .queueItem{ display:flex; align-items:center; gap:8px; padding:8px; border-radius:8px; background:linear-gradient(180deg, rgba(0,0,0,0.02), transparent); }
  .colorBox{ width:12px; height:12px; border-radius:3px; flex:0 0 12px }
  .offsetBadge{ margin-left:auto; font-size:13px; color:#444; font-weight:700 }
  .counters{ display:flex; gap:12px; margin-top:8px; }
  .counter{ padding:8px 10px; border-radius:8px; background:linear-gradient(180deg, rgba(0,0,0,0.03), transparent); font-weight:700 }
  .toggle{ display:inline-flex; gap:8px; align-items:center; padding:6px 8px; border-radius:999px; background:rgba(0,0,0,0.03) }
  .hidden{ display:none }
  .btn-correct{ background:#16a34a }
  .btn-wrong{ background:#ef4444 }
  /* responsive */
  @media (max-width:980px){
    .app{ padding:12px }
    .layout{ flex-direction:column; }
    .side{ width:100% }
  }
</style>
<style>
  /* ... existing styles ... */

  /* ===== Term row layout updates ===== */
  .termRow {
    display: flex;
    align-items: center;
    justify-content: space-between; /* left & right elements stick to edges */
    position: relative; /* allows termTitle to be centered absolutely */
  }

  .termTitle {
    font-size: 20px;
    font-weight: 700;
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
  }

  #triesLabel {
    flex-shrink: 0; /* ensures it doesn’t shrink */
  }

  .statusTag {
    flex-shrink: 0; /* ensures it doesn’t shrink */
  }
</style>

</head>
<body>
<div class="app" id="root">
  <div class="main">
    <div class="card controls">
      <div style="flex:1; min-width:260px">
        <label class="small">Import (Term | Definition, one per line)</label>
        <textarea id="importBox" rows="4" placeholder="e.g. Photosynthesis | Process plants use to convert sunlight"></textarea>
        <div style="display:flex; gap:8px; margin-top:8px">
          <button id="importBtn">Import</button>
    <button id="importSaveBtn">Import Save State</button>
    <button id="exportSaveBtn">Export Save State</button>
<button id="resetBtn" style="background:#ef4444; color:white; border:none; padding:8px 12px; border-radius:8px;">Reset</button>

          <input id="delayInput" type="number" value="2" min="0" style="width:80px" placeholder="Delay">
<label class="toggle" title="Dark mode">
  <input type="checkbox" id="darkToggle"> Dark
</label>

<div style="display:flex; gap:6px; align-items:center">
  <span class="small" id="Keybinds: text" hidden>Keybinds:</span>
  <input type="text" id="keyCorrect" maxlength="1" title="Key for Correct" style="width:24px" value="[">
  <input type="text" id="keyWrong" maxlength="1" title="Key for Wrong" style="width:24px" value="]">
</div>

        </div>
      </div>
<div id="sessionTimer">00:00</div>
<div id="avgTime">Avg sec/card: 0.0s</div>
<button id="pausePlayBtn" style="font-size:24px; width:48px; height:48px; border-radius:50%; border:none; cursor:pointer; display:none;"> ⏸</button>


      <div style="width:220px">
      </div>
    </div>

    <div class="layout">
      <div class="left">
        <div class="card">
          <div style="display:flex; justify-content:space-between; align-items:center">
            <div>
              <strong>Study</strong>
              <div class="small">Type answer → Enter (reveal) → Correct "[" / Wrong "]" </div>
            </div>
            <div style="display:flex; gap:8px; align-items:center">
              <button id="startBtn">Start Session</button>
              <button id="pauseBtn" class="ghost hidden">Pause</button>
            </div>
          </div>

          <div class="studyArea" id="studyArea" style="display:none">
<div class="termRow">
  <div id="triesLabel" class="small">Tries: 0</div>
  <div class="termTitle" id="termTitle">—</div>
  <div>
    <span id="statusTag" class="statusTag status-new">New</span>
  </div>
</div>

            <div class="definition" id="definitionBox"></div>
            <div>
              <input id="answerInput" type="text" placeholder="Type your answer and press Enter" autocomplete="off" />
            </div>

            <div id="judgeRow" style="display:none; margin-top:6px; display:flex; gap:8px">
              <button id="correctBtn" class="btn-correct" style="padding:8px 12px; border-radius:8px; color:white">Correct</button>
              <button id="wrongBtn" class="btn-wrong" style="padding:8px 12px; border-radius:8px; color:white">Wrong</button>
              <div id="nextInfo" class="small" style="margin-left:auto"></div>
            </div>
          </div>
        </div>

        <div id="sessionComplete" class="card hidden" style="margin-top:12px">
          <h3>Session complete</h3>
          <div class="small">You studied all queued cards.</div>
          <div style="margin-top:8px">
            <button id="restartBtn">Restart Session</button>
          </div>
        </div>
      </div>

      <div class="side">
        <div class="card queuePanel">
          <div class="queueHeader">
            <div><strong>Queue</strong></div>
            <div><button id="toggleQueueBtn" class="ghost">Hide</button></div>
          </div>

          <div class="counters" style="margin-top:6px">
            <div class="counter">New: <span id="countNew">0</span></div>
            <div class="counter">Active: <span id="countInQueue">0</span></div>
            <div class="counter">Mastered: <span id="countMastered">0</span></div>
          </div>

          <div id="queueList" class="queueList" style="margin-top:8px"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>


// Sequence for reinput
const reinputSequence = [5, 10, 15, 25, 40, 65, 105, 170]; // extend as needed

let sessionSeconds = 0;
let sessionTimerInterval = null;
let answeredCards = 0;

function startSessionTimer() {
  if (sessionTimerInterval) clearInterval(sessionTimerInterval);
  sessionSeconds = 0;
  answeredCards = 0;

  el('sessionTimer').textContent = "00:00";
  el('avgTime').textContent = "Avg sec/card: 0.0s";

  sessionTimerInterval = setInterval(() => {
    sessionSeconds++;
    const mins = String(Math.floor(sessionSeconds / 60)).padStart(2, '0');
    const secs = String(sessionSeconds % 60).padStart(2, '0');
    el('sessionTimer').textContent = `${mins}:${secs}`;
  }, 1000);
}

function incrementAnsweredCards() {
  answeredCards++;
  updateAvgTime();
}

function updateAvgTime() {
  if (answeredCards > 0) {
    const avg = (sessionSeconds / answeredCards).toFixed(1);
    el('avgTime').textContent = `Avg sec/card: ${avg}s`;
  } else {
    el('avgTime').textContent = `Avg sec/card: 0.0s`;
  }
}


// Start timer when session starts
function startSession() {
  // your existing session setup…
  nextCard();
  startSessionTimer(); // ⬅ add this
}

/* ========= Data model & persistence ========= */
let definitionRevealed = false;
const STORAGE_KEY = 'queueStudyApp.v1';

let store = {
  cards: [],   // { id, term, def, status:'new'|'learning'|'applying'|'mastered', streak:0 }
  settings: { wrongDelay: 2, darkMode: false }
};
let queue = []; // array of items: { cardId, offset? }  offset present only when reinserted (+5/+10)
let current = null; // { cardId, offset? }
let tries = 0;
let inputLocked = false;
let sessionActive = false;

// Helper IDs
const el = id => document.getElementById(id);

let timerRunning = false;

const pausePlayBtn = el('pausePlayBtn');

pausePlayBtn.addEventListener('click', () => {
  if (!sessionActive) return; // safety check

  if (timerRunning) {
    // Pause timer
    clearInterval(sessionTimerInterval);
    timerRunning = false;
    pausePlayBtn.textContent = '▶'; // play icon
  } else {
    // Resume timer
    sessionTimerInterval = setInterval(() => {
      sessionSeconds++;
      const mins = String(Math.floor(sessionSeconds / 60)).padStart(2, '0');
      const secs = String(sessionSeconds % 60).padStart(2, '0');
      el('sessionTimer').textContent = `${mins}:${secs}`;
      updateAvgTime();
    }, 1000);
    timerRunning = true;
    pausePlayBtn.textContent = '⏸'; // pause icon
  }
});

/* ---------- persistence ---------- */
function saveStore() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify({ store, queue }));
}
function loadStore() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (raw) {
      const parsed = JSON.parse(raw);
      if (parsed.store) store = parsed.store;
      if (Array.isArray(parsed.queue)) queue = parsed.queue;
    }
  } catch(e){ console.warn('load error', e); }
}
loadStore();

/* ========= Utilities ========= */
function uid(){ return Math.random().toString(36).slice(2,9); }
function getCard(id){ return store.cards.find(c=>c.id===id) || null; }
function mapStatusToClass(s){
  if(s==='new') return ['New','status-new','--'];
  if(s==='learning') return ['Learning','status-learning','--'];
  if(s==='applying') return ['Applying','status-applying','--'];
  if(s==='mastered') return ['Mastered','status-mastered','--'];
  return ['New','status-new','--'];
}
function updateCountersUI(){
  const newCount = store.cards.filter(c => c.status === 'new').length;
  const masteredCount = store.cards.filter(c => c.status === 'mastered').length;
  const totalCount = store.cards.length;

  let inQueueCount = queue.filter(item => {
    const c = getCard(item.cardId);
    return c && c.status !== 'new';
  }).length;
  if(current){
    const card = getCard(current.cardId);
    if(card && card.status !== 'new'){
      inQueueCount += 1; 
    }
  }

  el('countNew').textContent = newCount;
  el('countInQueue').textContent = inQueueCount;
  el('countMastered').textContent = `${masteredCount}/${totalCount}`;
}

/* ========= Import / Clear ========= */
el('importBtn').addEventListener('click', ()=>{
  const raw = el('importBox').value.trim();
  if(!raw) return;
  const lines = raw.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  for(const line of lines){
    const parts = line.split('|');
    if(parts.length < 2) continue;
    const term = parts[0].trim(), def = parts.slice(1).join('|').trim();
    store.cards.push({ id: uid(), term, def, status: 'new', streak: 0 });
  }
  el('importBox').value = '';
  // If session not active, add to queue so they will be studied in next session
  saveStore();
  renderQueueUI();
  updateCountersUI();
});
el('resetBtn').addEventListener('click', () => {
  if (!confirm('Are you sure you want to reset everything? This cannot be undone.')) return;

  // Reset store and queue
  store.cards = [];
  queue = [];

  // Preserve theme
  store.settings = {
    darkMode: store.settings.darkMode,
    keyCorrect: '[',
    keyWrong: ']'
  };

  // Reset session state
  current = null;
  tries = 0;
  inputLocked = false;
  sessionActive = false;

  // Reset timer
  sessionSeconds = 0;
  clearInterval(sessionTimerInterval);
  timerRunning = false;
  el('sessionTimer').textContent = '00:00';
  el('avgTime').textContent = 'Avg sec/card: 0.0s';

  // Reset UI
  el('studyArea').style.display = 'none';
  el('sessionComplete').classList.add('hidden');
  el('pausePlayBtn').style.display = 'none';
  el('pausePlayBtn').textContent = '⏸'; // reset icon to pause
  el('startBtn').style.display = 'inline-block';
  el('answerInput').disabled = true;
  el('answerInput').value = '';

  el('importBox').value = '';

  applyTheme();
  renderQueueUI();
  updateCountersUI();

  saveStore();
});




/* ========= Dark mode ========= */
const darkToggle = el('darkToggle');
darkToggle.addEventListener('change', ()=>{
  store.settings.darkMode = darkToggle.checked;
  applyTheme();
  saveStore();
});
function applyTheme(){
  if(store.settings.darkMode){
    document.documentElement.setAttribute('data-theme','dark');
    darkToggle.checked = true;
  } else {
    document.documentElement.removeAttribute('data-theme');
    darkToggle.checked = false;
  }
}
applyTheme();

/* ========= Queue & Session logic ========= */

function buildQueueFromCards(){
  // Build queue from all cards in stored order (clone)
  queue = store.cards.map(c=>({ cardId: c.id })); // initially no offsets
  saveStore();
  renderQueueUI();
  updateCountersUI();
}

/* ========= Start Session ========= */
el('startBtn').addEventListener('click', () => {
  if (store.cards.length === 0) {
    alert('No cards imported. Paste Term | Definition and Import.');
    return;
  }

  if (queue.length === 0) buildQueueFromCards();

  const d = parseInt(el('delayInput').value);
  store.settings.wrongDelay = isNaN(d) ? 0 : Math.max(0, d);
  saveStore();

  sessionActive = true;
  el('studyArea').style.display = 'block';
  el('sessionComplete').classList.add('hidden');

  current = null;
  tries = 0;
  inputLocked = false;

  renderQueueUI();
  updateCountersUI();

  // Show pause/play button now
  pausePlayBtn.style.display = 'inline-block';
  timerRunning = true;
  startSession(); // starts timer and shows first card
  
  // ✅ Hide the Start Session button
  el('startBtn').style.display = 'none';
});


el('restartBtn').addEventListener('click', ()=>{
  // restart fresh session with queue from store
  buildQueueFromCards();
  sessionActive = true;
  el('studyArea').style.display = 'block';
  el('sessionComplete').classList.add('hidden');
  nextCard();
});

/* End session */
function endSession(){
  sessionActive = false;
  el('studyArea').style.display = 'none';
  el('sessionComplete').classList.add('hidden');
  current = null;
  tries = 0;
  saveStore();
}

/* Pop next card */
function nextCard(){
  if(!sessionActive) return;
  
  if(queue.length === 0){
    // done
    el('studyArea').style.display = 'none';
    el('sessionComplete').classList.remove('hidden');
    current = null;
    tries = 0;
    renderQueueUI();
    updateCountersUI();
    saveStore();
    return;
  }

  // get the next queued item
  const item = queue.shift();
  current = item; // keep current card separate
  tries = 0;
  inputLocked = false;

  renderCurrentCard();
  renderQueueUI();
  updateCountersUI();
  saveStore();
}


/* Render the current shown card */
function renderCurrentCard(){
  if(!current){ el('termTitle').textContent = '—'; return; }
  const card = getCard(current.cardId);
  if(!card){ nextCard(); return; }

  el('termTitle').textContent = card.term;
  el('triesLabel').textContent = `Tries: ${tries}`;
  const [label, cls] = mapStatusToClass(card.status);
  el('statusTag').textContent = label;
  el('statusTag').className = `statusTag ${cls}`;

  el('definitionBox').style.display = 'none';
  el('definitionBox').textContent = '';
  el('judgeRow').style.display = 'none';
  el('answerInput').value = '';
  el('answerInput').disabled = false;
  el('answerInput').focus();

  definitionRevealed = false; // reset for new card
}


/* When user presses Enter to reveal definition */
el('answerInput').addEventListener('keydown', (e)=>{
  if(e.key === 'Enter' && !inputLocked && sessionActive && current){
    e.preventDefault();
    showDefinition();
  }
});

function showDefinition(){
  if(!current) return;
  const card = getCard(current.cardId);
  if(!card) return;
  el('definitionBox').textContent = card.def;
  el('definitionBox').style.display = 'block';
  el('judgeRow').style.display = 'flex';
  definitionRevealed = true; // mark definition as revealed
}


/* Wrong button logic:
   - increment tries
   - demote status one level
   - hide definition and lock input for wrongDelay seconds, then allow retry
   - note: card remains at front (we do not reinsert yet). Only when user eventually presses Correct will insertion happen
*/
el('wrongBtn').addEventListener('click', () => {
  if (!current) return;
  tries++;
  const card = getCard(current.cardId);
  if (!card) return;

  // Demote card status
  demoteCard(card);

  // Custom sequence offsets
  const seq = [5, 10, 15, 25, 40, 65, 105, 170];
  // Track the card's current sequence index (default to 0)
  card.reinputIndex = card.reinputIndex || 0;

  // Move back one step in the sequence on wrong (but not below 0)
  card.reinputIndex = Math.max(card.reinputIndex - 1, 0);
  current.offset = seq[card.reinputIndex];

  // Hide definition and lock input temporarily
  el('definitionBox').style.display = 'none';
  el('judgeRow').style.display = 'none';
  inputLocked = true;
  el('answerInput').disabled = true;

  const delayMs = (store.settings.wrongDelay || 0) * 1000;
  setTimeout(() => {
    inputLocked = false;
    el('answerInput').disabled = false;
    el('answerInput').focus();
    renderCurrentCard();
  }, delayMs);

  saveStore();
  renderQueueUI();
  updateCountersUI();
});


/* Correct button logic:
   - If tries === 0 or ===1? In our flow: user must press Enter to reveal, which does not increment tries.
     We increment tries when they press Wrong. So "first try" means tries === 0 (they typed and pressed Enter and then pressed Correct immediately.)
   - We'll follow: first correct without previous wrongs => first try
   - If there were any wrongs (tries >= 1) => considered multi-try
   - Based on that we insert back into queue with offset +10 (first try) or +5 (multi-try)
   - If first try, promote streak ++ else streak = 0
*/
el('correctBtn').addEventListener('click', ()=> {
  if(!current) return;
  const card = getCard(current.cardId);
  if(!card) return;

  const hadWrong = tries > 0;

  // promotion/demotion logic
  if(!hadWrong){
    card.streak = (card.streak || 0) + 1;
    if(card.streak === 1) card.status = 'learning';
    else if(card.streak === 2) card.status = 'applying';
    else if(card.streak >= 3) card.status = 'mastered';
  } else {
    card.streak = 0;
  }

  // sequence-based insertion offset
  card.reinputIndex = card.reinputIndex || 0;  // track index in sequence
  if(!hadWrong && card.reinputIndex < reinputSequence.length - 1){
    card.reinputIndex++; // move forward in sequence if correct
  }

  const insertAfter = reinputSequence[card.reinputIndex];
  const queueItem = { cardId: card.id, offset: insertAfter };
  queue.splice(insertAfter, 0, queueItem);

  saveStore();
  renderQueueUI();
  updateCountersUI();
  nextCard();
  incrementAnsweredCards();
});


/* Demotion (one level down) when Wrong is pressed */
function demoteCard(card){
  // levels: mastered -> applying -> learning -> new
  if(card.status === 'mastered') card.status = 'applying';
  else if(card.status === 'applying') card.status = 'learning';
  else if(card.status === 'learning') card.status = 'learning'; // prevent going below 'learning'
  else if(card.status === 'new') card.status = 'learning'; // move 'new' to 'learning' on wrong

  // reset streak when demoted
  card.streak = Math.max(0, (card.streak || 0) - 1);
}


/* ========= Queue panel rendering ========= */
function renderQueueUI(){
  const qList = el('queueList');
  qList.innerHTML = '';

  // 1️⃣ Add current card first
  if(current){
    const card = getCard(current.cardId);
    if(card){
      const node = document.createElement('div');
      node.className = 'queueItem current-card'; // optional CSS class

      const box = document.createElement('div');
      box.className = 'colorBox';
      box.style.background = getComputedStyle(document.documentElement)
                               .getPropertyValue('--' + card.status).trim();
      node.appendChild(box);

      const span = document.createElement('div');
      span.textContent = card.term;
      node.appendChild(span);

      // show offset if present
      if(current.offset){
        const off = document.createElement('div');
        off.className = 'offsetBadge';
        off.textContent = `+${current.offset}`;
        node.appendChild(off);
      }

      qList.appendChild(node);
    }
  }

  // 2️⃣ Add rest of queue
  for(let i = 0; i < queue.length; i++){
    const item = queue[i];
    // skip current card if somehow still in queue
    if(current && item.cardId === current.cardId) continue;

    const card = getCard(item.cardId);
    if(!card) continue;

    const node = document.createElement('div');
    node.className = 'queueItem';

    const box = document.createElement('div');
    box.className = 'colorBox';
    box.style.background = getComputedStyle(document.documentElement)
                             .getPropertyValue('--' + card.status).trim();
    node.appendChild(box);

    const span = document.createElement('div');
    span.textContent = card.term;
    node.appendChild(span);

    if(item.offset){
      const off = document.createElement('div');
      off.className = 'offsetBadge';
      off.textContent = `+${item.offset}`;
      node.appendChild(off);
    }

    qList.appendChild(node);
  }

  updateCountersUI();
}


/* Toggle queue panel visibility */
const toggleQueueBtn = el('toggleQueueBtn');
toggleQueueBtn.addEventListener('click', ()=>{
  const q = el('queueList');
  if(q.style.display === 'none'){ q.style.display = 'flex'; toggleQueueBtn.textContent = 'Hide'; }
  else { q.style.display = 'none'; toggleQueueBtn.textContent = 'Show'; }
});


/* Load persisted state into UI */
function initializeUI(){
  // settings
  el('delayInput').value = store.settings.wrongDelay || 0;
  store.settings.darkMode = store.settings.darkMode || false;
  darkToggle.checked = !!store.settings.darkMode;
  applyTheme();
  // if queue was persisted, use it; otherwise build from cards
  if(!queue || queue.length === 0) {
    // create initial queue only if cards exist
    if(store.cards.length) buildQueueFromCards();
  }
  renderQueueUI();
  updateCountersUI();
}
initializeUI();

/* helper: build queue from store.cards preserving order */
function buildQueueFromCards(){
  queue = store.cards.map(c=>({ cardId: c.id })); // offsets empty
  saveStore();
}

/* Persist store + queue whenever user leaves or on interval */
window.addEventListener('beforeunload', ()=> saveStore());

/* expose small debug functions to console if needed */
window.QSApp = { store, queue, saveStore, loadStore, nextCard, getCard };

// Initialize keybinds
store.settings.keyCorrect = store.settings.keyCorrect || '[';
store.settings.keyWrong = store.settings.keyWrong || ']';

// Update inputs with stored keys
el('keyCorrect').value = store.settings.keyCorrect;
el('keyWrong').value = store.settings.keyWrong;

// Save keybinds when changed
el('keyCorrect').addEventListener('change', e=>{
  store.settings.keyCorrect = e.target.value.slice(0,1);
  saveStore();
});
el('keyWrong').addEventListener('change', e=>{
  store.settings.keyWrong = e.target.value.slice(0,1);
  saveStore();
});

// Listen for key presses
document.addEventListener('keydown', e=>{
  if(!sessionActive) return;
    if(current && !inputLocked && definitionRevealed){ // check revealed
    if(e.key === store.settings.keyCorrect){
      e.preventDefault();
      el('correctBtn').click();
    }
    if(e.key === store.settings.keyWrong){
      e.preventDefault();
      el('wrongBtn').click();
    }
  }
});
/* ========= Import Save State ========= */
el('importSaveBtn').addEventListener('click', () => {
  const raw = el('importBox').value.trim();
  if (!raw) {
    alert('No save state data found in the import box.');
    return;
  }

  const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(Boolean);

  const importedCards = [];
  const newQueue = [];

  for (const line of lines) {
    const parts = line.split('|').map(p => p.trim());
    if (parts.length < 5) continue; // must have 5 fields
    const [term, def, status, offsetStr, reinputIndexStr] = parts;
    const offset = parseInt(offsetStr) || 0;
    const reinputIndex = parseInt(reinputIndexStr) || 0;
    const id = uid();
    const streak = status === 'mastered' ? 3 : (status === 'applying' ? 2 : (status === 'learning' ? 1 : 0));
    importedCards.push({ id, term, def, status, streak, reinputIndex });
    newQueue.push({ cardId: id, offset });
  }

  if (importedCards.length === 0) {
    alert('No valid cards found in import.');
    return;
  }

  // Replace store
  store.cards = importedCards;
  queue = newQueue;

  // Reset session state
  current = null;
  tries = 0;
  inputLocked = false;
  sessionActive = false;

  saveStore();
  renderQueueUI();
  updateCountersUI();
  renderCurrentCard();
  el('importBox').value = '';

  alert('Import complete.');
});





/* ========= Export Save State to Clipboard ========= */
function exportSaveStateToClipboard(){
  if(!current && queue.length === 0){
    alert('No cards to export.');
    return;
  }

  const exportLines = [];

  // 1️⃣ Export current card first
  if(current){
    const card = getCard(current.cardId);
    if(card){
      exportLines.push(`${card.term} | ${card.def} | ${card.status} | ${current.offset || 0} | ${card.reinputIndex || 0}`);

    }
  }

  // 2️⃣ Export remaining cards in queue order, skipping current
  for(const item of queue){
    if(current && item.cardId === current.cardId) continue; // skip duplicate
    const card = getCard(item.cardId);
    if(!card) continue;
    exportLines.push(`${card.term} | ${card.def} | ${card.status} | ${item.offset || 0} | ${card.reinputIndex || 0}`);

  }

  const exportText = exportLines.join('\n');

  // Copy to clipboard
  navigator.clipboard.writeText(exportText)
    .then(() => {
      alert('Save state copied to clipboard!');
    })
    .catch(err => {
      console.error('Failed to copy: ', err);
      alert('Failed to copy to clipboard.');
    });
}

/* Connect to your button */
el('exportSaveBtn').addEventListener('click', exportSaveStateToClipboard);


</script>
</body>
</html>


